04 - Helper

Um helper é uma classe JS que auxilia o controller em uma função específica. Um helper isola a responsabilidade de processar
dados e variáveis, tornando o controller menos verboso e mais organizado. Vejamos no código:

let data = new Date(...
    this._inputData.value
    .split('-')
    .map((item, indice) => item - indice % 2)
);

let negociacao = new Negociacao(
    data,
    this._inputQuantidade.value,
    this._inputValor.value
);

let diaMesAno = negociacao.data.getDate()
    + '/' + (negociacao.data.getMonth() + 1)
    + '/' + negociacao.data.getFullYear();

console.log(diaMesAno);

Essa aplicação tem por objetivo criar um objeto Date() a partir de uma string e em seguida retornar uma string a partir deste
objeto Date(). Porém toda a aplicação está no mesmo arquivo de uma forma corrida, veja que tudo está muito confuso e as
variáveis estão soltas no código. Vamos alocar este código no helper DateHelper.js, vejamos o código a seguir:

class DateHelper {
    dataParaTexto(data) {
            return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear()
        }
    textoParaData(texto) {
        return new Date(...texto.split('-').map((item, indice) => item - indice % 2));
    }
    
Podemos observar que agora a classe está bem organizada e cada método está bem segmentado. Existe um método que transforma
data para texto a partir de um objeto Date() e um que converte a string em um objeto Date(). Para alocarmos este código no
nosso controller podemos fazer da seguinte forma:

let helper = new DateHelper();

        let negociacao = new Negociacao(
            helper.textoParaData(this._inputData.value),
            this._inputQuantidade.value,
            this._inputValor.value
        );
        
        console.log(negociacao);
        console.log(helper.dataParaTexto(negociacao.data));

Note que o código ficou bem mais enxuto e os métodos deixaram o entendimento da aplicação mais claro.

Métodos estáticos: Observe que nosso helper não tem um constructor declarado e não tem nenhuma propriedade, mas ainda assim
precisamos instanciá-lo para chamá-lo no código com a linha de código new DateHelper. Se o método não pussui propriedade não é
necessário uma instância apenas para ele, em contrapartida poderíamos chamá-lo diretamente como uma definição de classe. Para
isso vamos transformar os métodos da classe DateHelper em estáticos da seguinte forma:

lass DateHelper {

    constructor() {
        throw new Error('Esta classe não pode ser instanciada');
    }
    static dataParaTexto(data) {
            return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear()
        }
    static textoParaData(texto) {
        return new Date(...texto.split('-').map((item, indice) => item - indice % 2));
    }
    
}

Adicionamos o comando static para dizer que nossos métodos agora podem ser chamados sem a necessidade de instância e de quebra
adicionamos um construtor de erro que retorna uma mensagem no console caso alguém tente fazer este procedimento. Agora podemos
chamar os métodos como queríamos, da seguinte forma:

let negociacao = new Negociacao(
            DateHelper.textoParaData(this._inputData.value),
            this._inputQuantidade.value,
            this._inputValor.value
        );
        
        console.log(negociacao);
        console.log(DateHelper.dataParaTexto(negociacao.data));

Usando o trecho de código DateHelper.textoParaDate() chamamos o método como uma definição de classe, isso só é possível pois
este método é estático e não tem propriedades, caso contrário sua classe deverá ser instanciada como qualquer outra para que
ele possa ser chamado no código.

Template strings: Apesar de não estar diretamente relacionada com o helper a função de template string. nova no ES6, merece
ser mencionada. Agora podemos concatenar strings e variáveis de uma maneira mais fluida, veja o código abaixo:

dataParaTexto(data) {

        return data.getDate()
            + '/' + (data.getMonth() + 1)
            + '/' + data.getFullYear();
      }

Temos o nosso código antigo do método usado no helper, vejamos agora como ele ficaria no modelo de template string:

static dataParaTexto(data) {

            return `${data.getDate()}/${data.getMonth()+1}/${data.getFullYear()}`;
        }

Perceba que todas as variáveis são inseridas em um bloco de ${} enquanto as strings ficam de fora e são automaticamente
concatenadas. É importante dizer que toda sintaxe deve ficar entre crases, ´mais exatamente neste formato´.

05 - VIEW

Já temos os models, os controllers e os helpers da nossa aplicação, agora precisamos criar um view para que os elementos
sejam renderizados em tela. Um view nada mais é do que uma classe que renderiza código HTML via Javascript através de
uma instância chamada em um elemento do DOM, para isso usaremos alguns recursos do ES6. Primeiro criamos um arquivo JS
para conter nosso código de view, dentro dele inserimos uma classe com uma função para imprimir uma template string, como
no código abaixo:

class NegociacaoView {
	template(){
		return `
			*CÓDIGO HTML*
		`;
	}
}

A template string possibilita que coloquemos um código HTML puro, como se estivéssemos escravendo no próprio documento. Em
seguida chamaremos o arquivo no index.html e adicionamos nosso código no controller, da seguinte forma:

constructor() {
...
	this._negociacoesView = new NegociacoesView();
...
}

Desta forma chamamos a aplicação no controller sempre que a classe principal for instanciada. Agora precisamos indicar no HTML
qual o ponto onde nossa view será renderizada, para isso usamos uma tag qualquer (pode ser uma div).

<div id="negociacoesView"></div>

Uma vez que já temos um ponto para receber o código precisamos informar qual elemento do DOM receberá nossa view, para isso
adicionamos um constructor à nossa classe view, da segunte forma:

class NegociacaoView {

	constructor(elemento){
		this._elemento = elemento;
	}
	template(){
		return `
			*CÓDIGO HTML*
		`;
	}
}

Agora buscamos o elemento do DOM na classe view que está no controller e adicionamos um método update para escrever o código
da classe view:


constructor() {
...
	this._negociacoesView = new NegociacoesView($('#negociacoesView'));

	this._negociacoesView.update();
...
}

Por fim criamos o método update na classe view para dar o retorno da função template:

   update() {

        this._elemento.innerHTML = this._template();
    }

Esse método utiliza o recurso innerHTML, que transforma strings em código possibilitando a iumpressão do código HTML via JS
sem maiores problemas.

Fundindo view e model: Agora que temos um método view completo vamos adicionar ados dinamicidade através do model. Passando os
elementos do model para o view podemos injetar código HTML dinamicamente, para isso precisamos vincular o método update ao
model, vamos começar passando o model comom parâmetro no controller para o update:

this._negociacoesView.update(this._listaNegociacoes);

Lembrando de chamar esse método não só no constructor, quando a página for carregada, mas em todo método que atualize a lista
do model. Em seguida passamos o model como marametro para o metodo updae e para o template:

 update(model) {

        this._elemento.innerHTML = this._template(model);
 }
...
_template(model){
...

Agora que o nosso template recebe os dados do model vamos adicionar expressões no corpo da tabela para que os dados do model
sejam impressos no view:

<tbody>
    ${model.negociacoes.map(n => {
        console.log(n);
        return n;
      })}
</tbody>

Utilizamos o map com a arrow function para injetar o código passado pelo model e nomeamos a variável "n", com o return n seria
gerada uma nova lista, porém o código acima não adiciona nenhuma mudança. Vamos inserir agora os dados dentro das tr da 
seguinte forma:

<tbody>
    ${model.negociacoes.map(n => {

      return `
        <tr>
            <td>${DateHelper.dataParaTexto(n.data)}</td>
            <td>${n.quantidade}</td>
            <td>${n.valor}</td>
            <td>${n.volume}</td>
        </tr>
      `
      }).join('')}
</tbody>

Inserimos uma template string como retorno e dentro desta template string inserimos expressões que injetam os dados dentro 
das tags tr na tabela. Desta forma sempre que a página for carregada ou sempre que a lista for atualizada o método template
vai inserir código HTML na página de acordo com o model que foi passado a ele.
Agora vamos aprender mais um recurso muito útil em view para o ES6. Digamos que queiramos calcular um valor que se acumula 
a cada interação, como um volume total. Para resolver esta questão podemos usar a função reduce, que é um modelo reduzido de
uma função auto evocativa, ou seja, uma função que é estruturada e é invocada logo em seguida. Veja a sintaxe:

 model.negociacoes.reduce((total, n) => total + n.volume, 0.0)

Utilizamos a função reduce com dois parâmetros: o valor inicial (0.0) e uma função com uma variável "total" e com o
parâmetro "n" herdado da outra função anterior. Usando a arrow function podemos definir a soma do total com o n.volume
sempre que algum volume existir, dessa forma esse volume será somado e guardado no valor da variável total. O 0.0 é o valor
inicial da sentença.

06 - Generalizando a solução da view:

Para começar vamos abordar duas funcionalidades do ES6. A primeira é a possibilidade de decalrar um método set no código,
essa função tem por objetivo atribuir valor a alguma variável, como no exemplo:

set texto(texto) {
	this._texto = texto;
}

Dessa forma quando chamarmos a função texto atriuiremos aquela mensagem àquele texto ao qual aquela mensagem é atribuída.
Porém, se chamarmos esta função sem nenhum parâmetro com qual valor ela será atribiuída? O ES6 também possibilia que ao
definir que uma função receberá um parâmetro esse parâmetro seja atribuído de um valor inicial padrão. Veja na sintaxe:

set texto(texto='valor inicial')

Desta forma se a função for instanciada mas não receber nenhum parâmetro para texto o padrão inicial será o valor inserido
no parâmetro de acordo com a sintaxe acima.

Herança entre classes: O ES6 nos dá a possibilidade de herdarmos métodos de classes agora. Para isso vejamos o exemplo:

class ViewFilha {
	constructor(elemento){
	this._elemento = elemento;
}
	update(model){
		this._elemento.innerHTML = this._metodo(model)
}
}

Na função acima temos um constructor e um método update, porém o que aconteceria se diversas outras funções também tivessem
estes mesmos elementos em seus escopos? Seriam todos reescritos? Podemos criar uma função pai que replica elementos que
aparecem em outras funções com o ES6, veja o exemplo novamente:

class View {
	constructor(elemento){
		this._elemento = elemento;
	}
	update(model){
		this._elemento.innerHTML = this._metodo(model);
	}
}

class ViewFilha extends View{
	constructor(elemento){
		super(elemento);
	}
}

Com a declaração abaixo a classe filha herda todos os métodos da classe pai, se rodarmos o código com essa sintaxe ele 
funcionará corretamente. Porém para a o método constructor é necessário criar uma chamada própria com o parâmetro
super(elemento), para que a classe não fique sem nenhum construtor. Outro fator interessante do recurso de herança é que
um mesmo método que está na função pai será sobreescrito se for novamente adicionado na função filha. Ainda podemos usar o
parâmetro super para complementarmos o método caso este tenha particularidades extras que a função pai não contempla. Para
isso teremos que invocar a super primeiro, veja o código:

class ViewFilha {
	constructor(elemento){
		super(elemento);
		*outras instruções da função*
	}
}

Dessa forma herda-se os parâmetros do pais e sobrescreve-se o restante como complemento.
Por fim é importante saber que a classe pai sempre tem que ser chamada antes das filhas no HTML caso contrário um erro de
identificação occorerá e o código não funciona.